#!/usr/bin/env python3
import argparse
import json
import platform
import os

CONFIG_FILE = os.path.join(os.environ['XDG_CONFIG_HOME'], 'hiccup/config.json')


class DistroNotSupportedError(Exception):
    def __init__(self, name):
        self.message = '{} isn\'t supported yet'.format(name)
        super().__init__(self.message)


class CommandFailedError(Exception):
    def __init__(self, name):
        self.message = 'failed to use {}'.format(name)
        super().__init__(self.message)


class CurrentDistro:
    __silent = ' > /dev/null 2>&1'
    __sudo = 'sudo '

    def __init__(self, id: str):
        try:
            with open(CONFIG_FILE) as file:
                data = json.load(file)
                self.__system_update_cmds = data['system_update_cmds']
                self.__extra_cmds = data['extra_cmds']
                self.__clean_cmds = data['clean_cmds']
                self.__shell_plugin_cmds = data['shell_plugin_cmds']
                self.__other_cmds = data['other_cmds']
        except Exception:
            pass

        self.id = id

        if self.is_supported():
            self.update_cmd = self.get_update_cmd()
            self.clean_cmd = self.get_clean_cmd()
            if self.has_extra_cmd():
                self.extra_cmd = self.get_extra_cmd()
        else:
            raise DistroNotSupportedError(self.id)

    def __get_cmd(self, dct: dict):
        return dct[self.id]

    def __sys_cmd(self, name: str, cmd: str, prepend='', append=''):
        result = os.system('{}{}{}'.format(prepend, cmd, append))
        if result != 0:
            raise CommandFailedError(name)
        return result

    def __run_items(self, msg: str, dct: dict):
        for name, cmd in dct.items():
            print(msg.format(name))
            result = self.__sys_cmd(name, cmd, append=self.__silent)
            if result != 0:
                raise CommandFailedError(name)

    def is_supported(self):
        return self.id in self.__system_update_cmds

    def has_extra_cmd(self):
        return self.id in self.__extra_cmds

    def get_update_cmd(self):
        return self.__get_cmd(self.__system_update_cmds)

    def get_extra_cmd(self):
        return self.__get_cmd(self.__extra_cmds)

    def get_clean_cmd(self):
        return self.__get_cmd(self.__clean_cmds)

    def update_system(self):
        self.__sys_cmd(self.id, self.update_cmd, prepend=self.__sudo)
        if self.has_extra_cmd():
            self.__sys_cmd(self.id, self.extra_cmd)

    def clean_system(self):
        print('cleaning up system...')
        self.__sys_cmd(self.id, self.clean_cmd, prepend=self.__sudo)

    def update_shell_plugins(self):
        msg = 'updating {} plugins...'
        return self.__run_items(msg, self.__shell_plugin_cmds)

    def update_other(self):
        msg = 'updating {}...'
        return self.__run_items(msg, self.__other_cmds)

    def update_all(self):
        self.update_system()
        self.update_shell_plugins()
        self.update_other()
        self.clean_system()


def run():
    current_distro = platform.freedesktop_os_release()["ID"]
    distro = CurrentDistro(current_distro)

    parser = argparse.ArgumentParser(
            description='a python script to help keep you up to date')
    parser.add_argument("--cleanonly", "-c", action="store_true",
                        default=False, dest="cleanonly",
                        help='only remove unneeded dependencies')
    parser.add_argument("--systemonly", "-s", action="store_true",
                        default=False, dest="systemonly",
                        help='only update through the system\'s package manager')  # noqa: E501
    args = parser.parse_args()

    if args.cleanonly:
        return distro.clean_system()
    if args.systemonly:
        return distro.update_system()

    return distro.update_all()


if __name__ == '__main__':
    if os.geteuid() == 0:
        print('please don\'t run this as root :(')
        exit(1)
    try:
        run()
        print('done!')
    except Exception as e:
        print(repr(e))
        exit(2)
